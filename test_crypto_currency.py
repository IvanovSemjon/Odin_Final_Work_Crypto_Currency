# -*- coding: utf-8 -*-
"""
Тесты для модуля конвертера криптовалют

Этот файл содержит unit-тесты для проверки основных функций
конвертера криптовалют. Тесты покрывают:
- Проверку структуры данных (словари валют)
- Функцию получения цен через API
- Обработку ошибок и исключений
- Математические расчеты конвертации
- Валидацию форматов данных
"""

import unittest
from unittest.mock import patch, MagicMock
import sys
import os

# Добавляем путь к основному модулю для импорта
# Это необходимо для корректного импорта функций из crypto_currency.py
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Импортируем тестируемые функции и данные
from crypto_currency import get_crypto_price, cryptocurrencies, fiat_currencies


class TestCryptoCurrency(unittest.TestCase):
    """
    Основной класс тестов для конвертера криптовалют
    
    Наследуется от unittest.TestCase для использования
    стандартных методов тестирования Python
    """
    
    def test_cryptocurrencies_dict(self):
        """
        Тест структуры и содержимого словаря криптовалют
        
        Проверяет:
        - Что cryptocurrencies является словарем
        - Что словарь не пустой (содержит валюты)
        - Что присутствуют основные криптовалюты (Bitcoin, Ethereum)
        
        Этот тест важен для проверки базовой структуры данных,
        на которой строится вся логика приложения
        """
        # Проверяем, что переменная является словарем
        self.assertIsInstance(cryptocurrencies, dict, 
                            "cryptocurrencies должен быть словарем")
        
        # Проверяем, что словарь содержит данные
        self.assertGreater(len(cryptocurrencies), 0, 
                         "Словарь криптовалют не должен быть пустым")
        
        # Проверяем наличие основных криптовалют
        self.assertIn("bitcoin", cryptocurrencies, 
                     "Bitcoin должен присутствовать в списке")
        self.assertIn("ethereum", cryptocurrencies, 
                     "Ethereum должен присутствовать в списке")
        
        print("✓ Тест словаря криптовалют прошел успешно")
    
    def test_fiat_currencies_dict(self):
        """
        Тест структуры и содержимого словаря фиатных валют
        
        Проверяет:
        - Что fiat_currencies является словарем
        - Что словарь содержит валюты
        - Что присутствуют основные мировые валюты (USD, EUR, RUB)
        
        Фиатные валюты - это традиционные государственные валюты,
        в которые конвертируются криптовалюты
        """
        # Проверяем тип данных
        self.assertIsInstance(fiat_currencies, dict, 
                            "fiat_currencies должен быть словарем")
        
        # Проверяем наличие данных
        self.assertGreater(len(fiat_currencies), 0, 
                         "Словарь фиатных валют не должен быть пустым")
        
        # Проверяем наличие основных мировых валют
        self.assertIn("usd", fiat_currencies, 
                     "Доллар США должен присутствовать в списке")
        self.assertIn("eur", fiat_currencies, 
                     "Евро должно присутствовать в списке")
        self.assertIn("rub", fiat_currencies, 
                     "Российский рубль должен присутствовать в списке")
        
        print("✓ Тест словаря фиатных валют прошел успешно")
    
    @patch('crypto_currency.requests.get')
    def test_get_crypto_price_success(self, mock_get):
        """
        Тест успешного получения данных о цене криптовалюты через API
        
        Использует mock для имитации успешного ответа от CoinGecko API.
        Проверяет:
        - Что функция возвращает данные при успешном запросе
        - Что структура ответа соответствует ожидаемой
        - Что цена корректно извлекается из ответа
        
        @patch декоратор заменяет реальный HTTP-запрос на mock-объект,
        что позволяет тестировать без интернет-соединения
        """
        # Создаем mock-объект для имитации HTTP-ответа
        mock_response = MagicMock()
        
        # Настраиваем mock для возврата тестовых данных в формате CoinGecko API
        mock_response.json.return_value = {
            "bitcoin": {  # ID криптовалюты
                "usd": 45000.0,  # Цена в долларах
                "usd_market_cap": 850000000000,  # Рыночная капитализация
                "usd_24h_vol": 25000000000,  # Объем торгов за 24 часа
                "usd_24h_change": 2.5  # Изменение цены за 24 часа в %
            }
        }
        # Имитируем отсутствие HTTP-ошибок
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
        
        # Вызываем тестируемую функцию
        result = get_crypto_price("bitcoin", "usd")
        
        # Проверяем результат
        self.assertIsNotNone(result, "Функция должна вернуть данные")
        self.assertIn("bitcoin", result, "Результат должен содержать данные о bitcoin")
        self.assertIn("usd", result["bitcoin"], "Должна быть цена в USD")
        self.assertEqual(result["bitcoin"]["usd"], 45000.0, 
                        "Цена должна соответствовать mock-данным")
        
        print("✓ Тест успешного получения цены криптовалюты прошел успешно")
    
    @patch('crypto_currency.requests.get')
    def test_get_crypto_price_api_error(self, mock_get):
        """
        Тест обработки ошибок при запросе к API
        
        Проверяет, что функция корректно обрабатывает различные типы ошибок:
        - Сетевые ошибки
        - Ошибки API
        - Неожиданные исключения
        
        Важно убедиться, что приложение не падает при проблемах с API,
        а возвращает None, что позволяет показать пользователю понятное сообщение
        """
        # Настраиваем mock для генерации исключения при вызове requests.get
        # side_effect позволяет mock-объекту выбрасывать исключение
        mock_get.side_effect = Exception("API Error")
        
        # Вызываем функцию, которая должна обработать ошибку
        result = get_crypto_price("bitcoin", "usd")
        
        # Проверяем, что функция вернула None при ошибке
        # Это означает, что ошибка была корректно обработана
        self.assertIsNone(result, 
                         "При ошибке API функция должна возвращать None")
        
        print("✓ Тест обработки ошибки API прошел успешно")
    
    @patch('crypto_currency.requests.get')
    def test_get_crypto_price_timeout(self, mock_get):
        """
        Тест обработки таймаута при запросе к API
        
        Таймаут - это ситуация, когда сервер не отвечает в течение
        заданного времени (в коде установлено 10 секунд).
        
        Проверяет:
        - Что функция не зависает при медленном интернете
        - Что таймаут обрабатывается как обычная ошибка
        - Что пользователь получит уведомление о проблеме
        """
        # Имитируем ситуацию таймаута
        # В реальности это может быть requests.exceptions.Timeout,
        # но для простоты используем общее исключение
        mock_get.side_effect = Exception("Timeout")
        
        # Вызываем функцию
        result = get_crypto_price("bitcoin", "usd")
        
        # Проверяем корректную обработку таймаута
        self.assertIsNone(result, 
                         "При таймауте функция должна возвращать None")
        
        print("✓ Тест обработки таймаута прошел успешно")
    
    def test_crypto_conversion_calculation(self):
        """
        Тест математических расчетов конвертации валют
        
        Проверяет основную формулу конвертации:
        Количество криптовалюты = Сумма в фиатной валюте / Цена криптовалюты
        
        Например: 1000 USD / 45000 USD за BTC = 0.02222222 BTC
        
        Проверяет:
        - Точность вычислений (до 8 знаков после запятой)
        - Что результат положительный
        - Что математика работает корректно
        """
        # Задаем тестовые данные
        amount = 1000.0  # Сумма для конвертации (например, 1000 USD)
        crypto_price = 45000.0  # Цена криптовалюты (например, 45000 USD за 1 BTC)
        
        # Ожидаемый результат по формуле
        expected_crypto_amount = amount / crypto_price
        
        # Выполняем расчет (имитируем логику из основного кода)
        crypto_amount = amount / crypto_price
        
        # Проверяем точность расчета до 8 знаков после запятой
        # Это важно для криптовалют, где точность критична
        self.assertAlmostEqual(crypto_amount, expected_crypto_amount, places=8,
                              msg="Расчет конвертации должен быть точным")
        
        # Проверяем, что результат положительный
        self.assertGreater(crypto_amount, 0, 
                          "Количество криптовалюты должно быть больше нуля")
        
        print("✓ Тест расчета конвертации прошел успешно")
    
    def test_currency_keys_consistency(self):
        """
        Тест согласованности формата ключей в словарях валют
        
        Проверяет, что все ключи в словарях написаны в нижнем регистре.
        Это важно для:
        - Единообразия данных
        - Корректной работы API (CoinGecko использует lowercase ID)
        - Предотвращения ошибок при поиске валют
        
        Например: "bitcoin", "ethereum", "usd", "eur" - правильно
        "Bitcoin", "ETHEREUM", "USD" - неправильно
        """
        # Проверяем ключи криптовалют
        for key in cryptocurrencies.keys():
            self.assertEqual(key, key.lower(), 
                           f"Ключ '{key}' должен быть в нижнем регистре")
        
        # Проверяем ключи фиатных валют
        for key in fiat_currencies.keys():
            self.assertEqual(key, key.lower(), 
                           f"Ключ '{key}' должен быть в нижнем регистре")
        
        print("✓ Тест согласованности ключей валют прошел успешно")
    
    def test_currency_values_format(self):
        """
        Тест формата отображаемых названий валют
        
        Проверяет, что значения в словарях имеют правильный формат:
        "Название валюты (КОД)"
        
        Примеры правильного формата:
        - "Bitcoin (BTC)"
        - "Доллар США (USD)"
        - "Ethereum (ETH)"
        
        Это важно для:
        - Корректного отображения в GUI
        - Понятности для пользователя
        - Единообразия интерфейса
        """
        # Проверяем формат названий криптовалют
        for key, value in cryptocurrencies.items():
            # Проверяем, что значение - строка
            self.assertIsInstance(value, str, 
                                f"Название '{key}' должно быть строкой")
            
            # Проверяем, что строка не пустая
            self.assertGreater(len(value), 0, 
                             f"Название '{key}' не должно быть пустым")
            
            # Проверяем наличие скобок (для кода валюты)
            self.assertIn("(", value, 
                         f"Название '{key}' должно содержать открывающую скобку")
            self.assertIn(")", value, 
                         f"Название '{key}' должно содержать закрывающую скобку")
        
        # Проверяем формат названий фиатных валют
        for key, value in fiat_currencies.items():
            self.assertIsInstance(value, str, 
                                f"Название '{key}' должно быть строкой")
            self.assertGreater(len(value), 0, 
                             f"Название '{key}' не должно быть пустым")
            self.assertIn("(", value, 
                         f"Название '{key}' должно содержать открывающую скобку")
            self.assertIn(")", value, 
                         f"Название '{key}' должно содержать закрывающую скобку")
        
        print("✓ Тест формата значений валют прошел успешно")


def run_tests():
    """
    Функция запуска всех unit-тестов с красивым выводом результатов
    
    Выполняет:
    1. Создание набора тестов (test suite)
    2. Запуск всех тестов из класса TestCryptoCurrency
    3. Сбор и анализ результатов
    4. Вывод подробной статистики
    
    Использует unittest.TextTestRunner для выполнения тестов
    и подавляет стандартный вывод для создания кастомного отчета
    """
    print("=" * 60)
    print("ЗАПУСК ОСНОВНЫХ ТЕСТОВ КОНВЕРТЕРА КРИПТОВАЛЮТ")
    print("=" * 60)
    
    # Создаем набор тестов из всех методов класса TestCryptoCurrency
    # TestLoader автоматически находит все методы, начинающиеся с 'test_'
    suite = unittest.TestLoader().loadTestsFromTestCase(TestCryptoCurrency)
    
    # Запускаем тесты с подавлением стандартного вывода
    # verbosity=0 - минимальный вывод
    # stream=open(os.devnull, 'w') - перенаправляем вывод в "никуда"
    runner = unittest.TextTestRunner(verbosity=0, stream=open(os.devnull, 'w'))
    result = runner.run(suite)
    
    # Выводим результаты в красивом формате
    print("\n" + "=" * 60)
    print("РЕЗУЛЬТАТЫ ОСНОВНОГО ТЕСТИРОВАНИЯ")
    print("=" * 60)
    
    # Анализируем результаты тестирования
    if result.wasSuccessful():
        print(f"✅ Все тесты прошли успешно! Выполнено: {result.testsRun} тестов")
        print("✅ Основные функции работают корректно!")
    else:
        # Выводим информацию об ошибках
        print(f"❌ Обнаружены ошибки в {len(result.failures + result.errors)} тестах")
        
        # Показываем детали каждой ошибки
        for test, error in result.failures + result.errors:
            print(f"❌ {test}: {error}")
    
    print("=" * 60)


# Точка входа для запуска тестов напрямую
if __name__ == "__main__":
    # Запускаем все тесты, если файл выполняется напрямую
    # (а не импортируется как модуль)
    run_tests()