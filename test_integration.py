# -*- coding: utf-8 -*-
"""
Интеграционные тесты для конвертера криптовалют

Этот файл содержит интеграционные тесты, которые проверяют:
- Взаимодействие между различными компонентами системы
- Полный цикл конвертации от запроса до результата
- Работу с реальными структурами данных
- Совместимость различных валют и форматов
- Обработку граничных случаев в реальных сценариях

Интеграционные тесты дополняют unit-тесты, проверяя систему как единое целое
"""

import unittest
from unittest.mock import patch, MagicMock
import sys
import os

# Добавляем путь к основному модулю для корректного импорта
# Это необходимо для работы тестов независимо от текущей директории
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

# Импортируем тестируемые компоненты
from crypto_currency import get_crypto_price, cryptocurrencies, fiat_currencies


class TestIntegration(unittest.TestCase):
    """
    Класс интеграционных тестов для проверки взаимодействия компонентов
    
    Интеграционные тесты проверяют, как различные части системы
    работают вместе, а не по отдельности
    """
    
    @patch('crypto_currency.requests.get')
    def test_full_conversion_workflow(self, mock_get):
        """
        Тест полного рабочего процесса конвертации от начала до конца
        
        Этот тест имитирует полный пользовательский сценарий:
        1. Пользователь выбирает криптовалюту и фиатную валюту
        2. Система запрашивает актуальную цену через API
        3. Выполняется математический расчет конвертации
        4. Проверяется корректность всех промежуточных и финальных результатов
        
        Проверяет интеграцию между:
        - API-запросами (get_crypto_price)
        - Обработкой данных
        - Математическими вычислениями
        - Валидацией результатов
        """
        # Настраиваем mock для имитации успешного ответа от CoinGecko API
        mock_response = MagicMock()
        
        # Создаем реалистичные тестовые данные в формате CoinGecko API
        mock_response.json.return_value = {
            "bitcoin": {  # ID криптовалюты
                "usd": 50000.0,  # Цена в долларах
                "usd_market_cap": 1000000000000,  # Рыночная капитализация ($1T)
                "usd_24h_vol": 30000000000,  # Объем торгов за 24ч ($30B)
                "usd_24h_change": 1.5  # Изменение за 24ч (+1.5%)
            }
        }
        # Имитируем отсутствие HTTP ошибок
        mock_response.raise_for_status.return_value = None
        mock_get.return_value = mock_response
        
        # Задаем параметры для тестового сценария
        amount = 1000.0  # Сумма для конвертации (1000 USD)
        crypto_id = "bitcoin"  # ID криптовалюты в системе CoinGecko
        fiat_currency = "usd"  # Код фиатной валюты
        
        # ШАГ 1: Получаем данные о цене через API
        price_data = get_crypto_price(crypto_id, fiat_currency)
        self.assertIsNotNone(price_data, 
                           "API должен вернуть данные о цене")
        
        # ШАГ 2: Извлекаем цену из полученных данных
        crypto_price = price_data[crypto_id][fiat_currency]
        
        # ШАГ 3: Выполняем расчет конвертации (основная бизнес-логика)
        crypto_amount = amount / crypto_price
        
        # ШАГ 4: Проверяем корректность всех результатов
        self.assertEqual(crypto_price, 50000.0, 
                        "Цена должна соответствовать mock-данным")
        self.assertEqual(crypto_amount, 0.02, 
                        "1000 USD / 50000 USD/BTC = 0.02 BTC")
        
        # Дополнительные проверки целостности данных
        self.assertIn("usd_market_cap", price_data[crypto_id], 
                     "Данные должны содержать рыночную капитализацию")
        self.assertIn("usd_24h_vol", price_data[crypto_id], 
                     "Данные должны содержать объем торгов")
        self.assertIn("usd_24h_change", price_data[crypto_id], 
                     "Данные должны содержать изменение цены")
        
        print("✓ Тест полного процесса конвертации прошел успешно")
    
    def test_multiple_currencies_support(self):
        """
        Тест поддержки множественных валют и их совместимости
        
        Проверяет, что система поддерживает достаточное количество
        популярных криптовалют и фиатных валют для практического использования.
        
        Это важно для:
        - Удовлетворения потребностей различных пользователей
        - Международной применимости приложения
        - Покрытия основных торговых пар на криптобиржах
        
        Проверяет наличие:
        - Топ криптовалют по капитализации
        - Основных мировых фиатных валют
        - Региональных валют (включая рубль для российских пользователей)
        """
        # Список обязательных криптовалют (топ по рыночной капитализации)
        required_cryptos = [
            "bitcoin",    # BTC - первая и крупнейшая криптовалюта
            "ethereum",   # ETH - вторая по капитализации, платформа для DeFi
            "tether",     # USDT - крупнейший стейблкоин
            "solana"      # SOL - популярная высокопроизводительная блокчейн-платформа
        ]
        
        # Проверяем наличие каждой обязательной криптовалюты
        for crypto in required_cryptos:
            self.assertIn(crypto, cryptocurrencies, 
                         f"Криптовалюта {crypto} должна поддерживаться системой")
        
        # Список обязательных фиатных валют (основные мировые + региональные)
        required_fiats = [
            "usd",  # Доллар США - основная резервная валюта мира
            "eur",  # Евро - валюта Европейского союза
            "rub",  # Российский рубль - для российских пользователей
            "gbp"   # Фунт стерлингов - валюта Великобритании
        ]
        
        # Проверяем наличие каждой обязательной фиатной валюты
        for fiat in required_fiats:
            self.assertIn(fiat, fiat_currencies, 
                         f"Фиатная валюта {fiat} должна поддерживаться системой")
        
        # Дополнительная проверка: убеждаемся, что есть достаточное разнообразие
        self.assertGreaterEqual(len(cryptocurrencies), 10, 
                               "Должно поддерживаться минимум 10 криптовалют")
        self.assertGreaterEqual(len(fiat_currencies), 15, 
                               "Должно поддерживаться минимум 15 фиатных валют")
        
        print("✓ Тест поддержки множественных валют прошел успешно")
    
    def test_edge_cases(self):
        """
        Тест граничных случаев и экстремальных значений
        
        Граничные случаи - это ситуации на "краях" допустимых значений,
        которые могут вызвать неожиданное поведение программы.
        
        Проверяет:
        - Очень маленькие суммы (микротранзакции)
        - Очень большие суммы (крупные инвестиции)
        - Высокие цены криптовалют
        - Точность вычислений при экстремальных значениях
        
        Это важно для:
        - Предотвращения ошибок округления
        - Поддержки различных сценариев использования
        - Обеспечения стабильности при любых входных данных
        """
        # ТЕСТ 1: Очень маленькие суммы (микротранзакции)
        # Например, пользователь хочет купить криптовалюту на 1 цент
        small_amount = 0.01  # $0.01
        crypto_price = 50000.0  # $50,000 за BTC
        
        crypto_amount = small_amount / crypto_price
        
        # Проверяем, что результат положительный и не равен нулю
        self.assertGreater(crypto_amount, 0, 
                          "Даже очень маленькие суммы должны давать положительный результат")
        
        # Проверяем точность для маленьких чисел (должно быть 0.0000002 BTC)
        expected_small = 0.0000002
        self.assertAlmostEqual(crypto_amount, expected_small, places=7,
                              msg="Расчет для маленьких сумм должен быть точным")
        
        # ТЕСТ 2: Очень большие суммы (крупные инвестиции)
        # Например, институциональный инвестор покупает на $1 миллион
        large_amount = 1000000.0  # $1,000,000
        
        crypto_amount_large = large_amount / crypto_price
        
        # Проверяем корректность расчета для больших сумм
        self.assertGreater(crypto_amount_large, 0, 
                          "Большие суммы должны корректно обрабатываться")
        
        # Проверяем точность (должно быть 20 BTC)
        expected_large = 20.0
        self.assertEqual(crypto_amount_large, expected_large,
                        "1,000,000 USD / 50,000 USD/BTC = 20 BTC")
        
        # ТЕСТ 3: Экстремально высокие цены
        # Тестируем ситуацию с очень дорогой криптовалютой
        extreme_price = 1000000.0  # $1,000,000 за единицу
        normal_amount = 1000.0     # $1,000
        
        crypto_amount_expensive = normal_amount / extreme_price
        
        self.assertGreater(crypto_amount_expensive, 0,
                          "Высокие цены не должны ломать расчеты")
        self.assertEqual(crypto_amount_expensive, 0.001,
                        "1,000 USD / 1,000,000 USD/unit = 0.001 unit")
        
        # ТЕСТ 4: Проверка на переполнение и точность
        # Убеждаемся, что Python корректно обрабатывает большие числа
        huge_amount = 999999999.99
        reasonable_price = 45000.0
        
        result = huge_amount / reasonable_price
        self.assertIsInstance(result, float, "Результат должен быть числом с плавающей точкой")
        self.assertGreater(result, 0, "Результат должен быть положительным")
        
        print("✓ Тест граничных случаев прошел успешно")
    
    def test_data_consistency(self):
        """
        Тест согласованности и целостности данных в системе
        
        Проверяет, что структуры данных имеют разумные размеры и
        соответствуют ожиданиям реального использования.
        
        Согласованность данных важна для:
        - Производительности приложения (не слишком много вариантов)
        - Удобства пользователя (достаточно вариантов для выбора)
        - Поддерживаемости кода (разумное количество для обновления)
        
        Проверяет:
        - Разумные границы количества поддерживаемых валют
        - Отсутствие дублирующихся записей
        - Корректность структуры данных
        """
        # ПРОВЕРКА 1: Количество криптовалют в разумных пределах
        crypto_count = len(cryptocurrencies)
        
        # Минимум: должно быть достаточно для практического использования
        self.assertGreaterEqual(crypto_count, 10, 
                               "Должно поддерживаться минимум 10 криптовалют для практичности")
        
        # Максимум: не должно быть слишком много для удобства пользователя
        self.assertLessEqual(crypto_count, 100, 
                            "Не должно быть более 100 криптовалют для удобства выбора")
        
        # ПРОВЕРКА 2: Количество фиатных валют в разумных пределах
        fiat_count = len(fiat_currencies)
        
        # Минимум: основные мировые валюты
        self.assertGreaterEqual(fiat_count, 10, 
                               "Должно поддерживаться минимум 10 фиатных валют")
        
        # Максимум: не перегружать интерфейс
        self.assertLessEqual(fiat_count, 50, 
                            "Не должно быть более 50 фиатных валют")
        
        # ПРОВЕРКА 3: Отсутствие дублирующихся ключей
        crypto_keys = list(cryptocurrencies.keys())
        unique_crypto_keys = set(crypto_keys)
        self.assertEqual(len(crypto_keys), len(unique_crypto_keys), 
                        "Не должно быть дублирующихся ключей криптовалют")
        
        fiat_keys = list(fiat_currencies.keys())
        unique_fiat_keys = set(fiat_keys)
        self.assertEqual(len(fiat_keys), len(unique_fiat_keys), 
                        "Не должно быть дублирующихся ключей фиатных валют")
        
        # ПРОВЕРКА 4: Отсутствие пересечений между криптовалютами и фиатными валютами
        crypto_keys_set = set(cryptocurrencies.keys())
        fiat_keys_set = set(fiat_currencies.keys())
        intersection = crypto_keys_set.intersection(fiat_keys_set)
        
        self.assertEqual(len(intersection), 0, 
                        f"Не должно быть пересечений между типами валют: {intersection}")
        
        # ПРОВЕРКА 5: Все значения непустые и корректные
        for key, value in cryptocurrencies.items():
            self.assertIsInstance(key, str, f"Ключ {key} должен быть строкой")
            self.assertIsInstance(value, str, f"Значение для {key} должно быть строкой")
            self.assertGreater(len(key.strip()), 0, f"Ключ {key} не должен быть пустым")
            self.assertGreater(len(value.strip()), 0, f"Значение для {key} не должно быть пустым")
        
        for key, value in fiat_currencies.items():
            self.assertIsInstance(key, str, f"Ключ {key} должен быть строкой")
            self.assertIsInstance(value, str, f"Значение для {key} должно быть строкой")
            self.assertGreater(len(key.strip()), 0, f"Ключ {key} не должен быть пустым")
            self.assertGreater(len(value.strip()), 0, f"Значение для {key} не должно быть пустым")
        
        print("✓ Тест согласованности данных прошел успешно")


def run_integration_tests():
    """
    Функция запуска интеграционных тестов с детальным отчетом
    
    Интеграционные тесты проверяют взаимодействие между компонентами,
    в отличие от unit-тестов, которые тестируют отдельные функции.
    
    Выполняет:
    1. Загрузку всех интеграционных тестов из класса TestIntegration
    2. Запуск тестов с подавлением стандартного вывода
    3. Анализ и представление результатов в удобном формате
    4. Вывод статистики и рекомендаций
    
    Интеграционные тесты особенно важны для:
    - Проверки совместной работы API и бизнес-логики
    - Валидации полных пользовательских сценариев
    - Обнаружения проблем взаимодействия между модулями
    """
    print("=" * 60)
    print("ЗАПУСК ИНТЕГРАЦИОННЫХ ТЕСТОВ КОНВЕРТЕРА КРИПТОВАЛЮТ")
    print("=" * 60)
    
    # Создаем набор интеграционных тестов
    # TestLoader автоматически находит все методы, начинающиеся с 'test_'
    suite = unittest.TestLoader().loadTestsFromTestCase(TestIntegration)
    
    # Запускаем тесты с минимальным выводом для создания кастомного отчета
    # Подавляем стандартный вывод unittest для более читаемого результата
    runner = unittest.TextTestRunner(verbosity=0, stream=open(os.devnull, 'w'))
    result = runner.run(suite)
    
    # Выводим результаты в красивом формате
    print("\n" + "=" * 60)
    print("РЕЗУЛЬТАТЫ ИНТЕГРАЦИОННОГО ТЕСТИРОВАНИЯ")
    print("=" * 60)
    
    # Анализируем результаты тестирования
    if result.wasSuccessful():
        print(f"✅ Все интеграционные тесты прошли успешно!")
        print(f"📊 Выполнено тестов: {result.testsRun}")
        print("✅ Интеграция всех компонентов работает корректно!")
        print("🔗 Взаимодействие между модулями функционирует правильно")
    else:
        # Подробная информация об ошибках
        total_errors = len(result.failures + result.errors)
        print(f"❌ Обнаружены проблемы в {total_errors} интеграционных тестах")
        print(f"📊 Успешно: {result.testsRun - total_errors}, Неудачно: {total_errors}")
        
        # Показываем детали каждой ошибки для диагностики
        if result.failures:
            print("\n🔍 ДЕТАЛИ НЕУДАЧНЫХ ТЕСТОВ:")
            for test, traceback in result.failures:
                print(f"❌ {test}: {traceback}")
        
        if result.errors:
            print("\n⚠️ ОШИБКИ ВЫПОЛНЕНИЯ:")
            for test, traceback in result.errors:
                print(f"💥 {test}: {traceback}")
    
    print("=" * 60)


# Точка входа для запуска интеграционных тестов напрямую
if __name__ == "__main__":
    # Запускаем интеграционные тесты, если файл выполняется напрямую
    # (а не импортируется как модуль)
    run_integration_tests()